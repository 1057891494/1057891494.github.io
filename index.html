<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>笔记心得</title>
</head>
<style>
.Que {
    font-size: 25px;
    background-color: #E67C7C;
}

.Ans {
    font-size: 25px;
    background-color: #9EE284;
}

p {
    font-size: 18px;
}
</style>

<body>
    <div>
        <span class="Que">Question:</span>
        <p>div p:nth-child(1)并没有指向第一个p标签</p>
    </div>
    <div>
        <span class="Ans">Answer:</span>
        <p>nth-child()选择器不区分元素类型，默认从第一个元素开始，需要添加选择的类型，可以使用p:nth-of-type()</p>
    </div>
    <div>
        <span class="Que">Question:</span>
        <p>由于canvas存在canvas和canvas.getBoundingClientRect()两个画布，需要解决缩放问题</p>
    </div>
    <div>
        <span class="Ans">Answer:</span>
        <p>left:(left-canvasLeft+width/2)/(bbox.width/canvas.width),</p>
        <p>top:(top-canvasTop+height/2)/(bbox.height/canvas.height)</p>
        <p>其中</p>
        <p> left为鼠标距离html左侧距离，canvasLeft为画布在html中left距离</p>
        <p>width为触发事件园的宽度， (bbox.width/canvas.width)为缩放比例，图画都会首先画在canvas中，然后缩放到bbox</p>
    </div>
    <div>
        <span class="Que">Question:</span>
        <p>canvas中画的圆会变成椭圆</p>
    </div>
    <div>
        <span class="Ans">Answer:</span>
        <p>canvas默认大小为300*150，需要人为指定大小</p>
    </div>
    <div>
        <span class="Que">Question:</span>
        <p>图形之间会画出意想不到的线条</p>
    </div>
    <div>
        <span class="Ans">Answer:</span>
        <p>画完之后使用close Path（）闭合 可以选择closePath(); context.stroke(); 或者 context.stroke(); closePath();
        </p>
    </div>
    <div>
        <span class="Que">Question:</span>
        <p>控制台弹出未添加注解警告</p>
    </div>
    <div>
        <span class="Ans">Answer:</span>
        <p>无论在控制器中还是指令中的controller中，都需要为其注入实例。</p>
    </div>
    <div>
        <span class="Que">Question:</span>
        <p>async function logInOrder(urls) {</br>
         &nbsp;&nbsp;// 并发读取远程URL </br>
        &nbsp;&nbsp;const textPromises = urls.map(async url => { </br>
 &nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url);</br>
  &nbsp;&nbsp;&nbsp;&nbsp;return response.text();</br> });</br>
   // 按次序输出 </br>
&nbsp;&nbsp;for (const textPromise of textPromises) {</br> 
&nbsp;&nbsp;&nbsp;&nbsp;console.log(await textPromise); </br>
&nbsp;&nbsp;} </br>
} </br>
上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。
        </p>
        <p>个人对以上的理解：</br>一调用async函数就立即返回一个Promise对象，利用这点，可以将async函数放在循环中并在await后面添加异步执行函数实现并发操作，同时可以将async函数返回的值存放在数组中，通过遍历实现顺序输出</br>模拟以上情况：</br>
            [1,2,3,4,5].map(async (value)=>{</br>
            &nbsp;&nbsp;var date=new Date();</br>
            &nbsp;&nbsp;while(new Date().getTime()
            <date.getTime()+6000-value*1000){}</br>
            &nbsp;&nbsp;console.log(value);</br>
            &nbsp;&nbsp;var s=await new Promise((resolve,reject)=>{</br>
            &nbsp;&nbsp;&nbsp;&nbsp;resolve(value);</br>
            &nbsp;&nbsp;});</br>
            &nbsp;&nbsp;console.log(s);</br>
                });</br>但是并没有实现54321输出（5的时间最短）</p>
    </div>
    <div>
        <span class="Ans">Answer:</span>
    </div>
</body>

</html>
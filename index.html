<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>笔记心得</title>
</head>
<style>
.Que {
    font-size: 25px;
    background-color: #E67C7C;
}

.Ans {
    font-size: 25px;
    background-color: #9EE284;
}

p {
    font-size: 18px;
}
</style>

<body>
    <div>
        <span class="Que">Question:</span>
        <p>div p:nth-child(1)并没有指向第一个p标签</p>
    </div>
    <div>
        <span class="Ans">Answer:</span>
        <p>nth-child()选择器不区分元素类型，默认从第一个元素开始，需要添加选择的类型，可以使用p:nth-of-type()</p>
    </div>
    <div>
        <span class="Que">Question:</span>
        <p>由于canvas存在canvas和canvas.getBoundingClientRect()两个画布，需要解决缩放问题</p>
    </div>
    <div>
        <span class="Ans">Answer:</span>
        <p>left:(left-canvasLeft+width/2)/(bbox.width/canvas.width),</p>
        <p>top:(top-canvasTop+height/2)/(bbox.height/canvas.height)</p>
        <p>其中</p>
        <p> left为鼠标距离html左侧距离，canvasLeft为画布在html中left距离</p>
        <p>width为触发事件园的宽度， (bbox.width/canvas.width)为缩放比例，图画都会首先画在canvas中，然后缩放到bbox</p>
    </div>
    <div>
        <span class="Que">Question:</span>
        <p>canvas中画的圆会变成椭圆</p>
    </div>
    <div>
        <span class="Ans">Answer:</span>
        <p>canvas默认大小为300*150，需要人为指定大小</p>
    </div>
    <div>
        <span class="Que">Question:</span>
        <p>图形之间会画出意想不到的线条</p>
    </div>
    <div>
        <span class="Ans">Answer:</span>
        <p>画完之后使用close Path（）闭合 可以选择closePath(); context.stroke(); 或者 context.stroke(); closePath();
        </p>
    </div>
    <div>
        <span class="Que">Question:</span>
        <p>控制台弹出未添加注解警告</p>
    </div>
    <div>
        <span class="Ans">Answer:</span>
        <p>无论在控制器中还是指令中的controller中，都需要为其注入实例。</p>
    </div>
    <div>
        <span class="Que">Question:</span>
        <p>本人新手，在学习阮一峰大师的ES6，看到这里：</br>
            async function logInOrder(urls) {</br>
            </br>
            &nbsp;&nbsp;// 并发读取远程URL </br>
            &nbsp;&nbsp;const textPromises = urls.map(async url => { </br>
            &nbsp;&nbsp;&nbsp;&nbsp;const response = await fetch(url);</br>
            &nbsp;&nbsp;&nbsp;&nbsp;return response.text();</br>
            &nbsp;&nbsp;});</br>
            </br>
            &nbsp;&nbsp;// 按次序输出 </br>
            &nbsp;&nbsp;for (const textPromise of textPromises) {</br>
            &nbsp;&nbsp;&nbsp;&nbsp;console.log(await textPromise); </br>
            &nbsp;&nbsp;} </br>
            } </br>
            上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。</br>
            上面代码使用fetch方法，同时远程读取一组 URL。每个fetch操作都返回一个 Promise 对象，放入textPromises数组。</br>
            以上摘自阅读内容，根据大师的话“只有async函数内部是继发执行”，我有两种理解：1：map()函数内的方法是并发执行的。2：map()函数中的async函数之间是并发执行的。</br>为了验证，我自己写了一个方法，用计时模拟异步事件：</br>
            [1,2,3,4,5].map(</br>
            </br>
            &nbsp;&nbsp;(value)=>{</br>
            &nbsp;&nbsp;&nbsp;&nbsp;var date=new Date();</br>
            &nbsp;&nbsp;&nbsp;&nbsp;while(new Date().getTime()&lt;date.getTime()+6000-value*1000){}</br>
            &nbsp;&nbsp;&nbsp;&nbsp;;console.log(value);</br>
            &nbsp;&nbsp;}</br>
            );</br>
            结果是按顺序输出1，2，3，4，5.</br>
            于是我怀疑是async函数之间是并发的：</br>
            [1,2,3,4,5].map(</br>
            </br>
            &nbsp;&nbsp;async (value)=>{</br>
            &nbsp;&nbsp;&nbsp;&nbsp;var date=new Date();</br>
            &nbsp;&nbsp;&nbsp;&nbsp;while(new Date().getTime()&lt;date.getTime()+6000-value*1000){}</br>
            &nbsp;&nbsp;&nbsp;&nbsp;console.log(value);</br>
            &nbsp;&nbsp;}</br>
            );</br>
            结果依然是1，2，3，4，5.</br>
            以上两种情况并没有实现并发（5在1之前输出，我试过增加while的循环时间，但是没有效果）</br>
            于是我想问；1.map()是不是一个并发执行的函数？2.async函数之间是并发的吗？3.我的代码有什么问题吗？</p>
    </div>
    <div>
        <span class="Ans">Answer:</span>
    </div>
</body>

</html>